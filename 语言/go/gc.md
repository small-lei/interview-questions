# go 垃圾回收
#### Go 垃圾回收机制的特点

Go 的垃圾回收器是并发的、低延迟的，具体有以下几个特点：

并发性：垃圾回收过程与程序的执行是并发的，不需要暂停整个程序来进行内存回收。

三色标记法：Go 的垃圾回收器基于“三色标记法”实现，在内存回收时通过三种颜色（白色、灰色、黑色）来标记对象的状态，以确定哪些对象需要回收。

分代策略：Go 使用了“年轻代”和“老年代”对象的管理策略，但不像 Java 的分代垃圾回收那样显式。Go 倾向于频繁回收短生命周期对象，以减少内存占用。

#### 三色标记清除算法
Go 的垃圾回收器基于三色标记法，它将所有对象分为三类：

白色：表示对象尚未被检查，可能是垃圾，需要被回收。

灰色：表示对象已被发现，但它引用的其他对象还未检查。

黑色：表示对象和它引用的所有对象都已经被检查，不会被回收。

回收过程：

标记阶段：GC 线程从程序中的根对象（全局变量、栈上的局部变量等）开始，将可达的对象标记为灰色。然后继续检查这些对象的引用，逐步将它们标记为黑色，最终所有可达对象都会被标记为黑色，剩下的白色对象（不可达对象）则可以被回收。

清除阶段：GC 线程清除所有未标记（白色）的对象，将其内存释放给系统。

#### Go 1.5 之后的并发垃圾回收
```text
自 Go 1.5 版本开始，Go 实现了并发垃圾回收。这意味着垃圾回收线程和程序的主线程是并行执行的，减少了程序因垃圾回收而暂停的时间。

具体步骤如下：

STW（Stop-The-World）阶段：垃圾回收开始时，Go 会短暂地暂停程序的执行来进行一些必要的设置操作，例如确定所有的根对象。
并发标记阶段：在这个阶段，Go 的垃圾回收器与程序并发执行，通过并行化标记过程来识别哪些对象是存活的。
并发清除阶段：回收白色对象的内存资源，同时程序继续正常执行。
```

# golang gc会在什么时候执行
在 Go 语言中，垃圾回收（Garbage Collection, GC）是自动进行的，它会在运行时负责管理内存，自动回收不再使用的内存对象。Go 的垃圾回收器采用的是一种并发的、非分代、三色标记清除算法。具体来说，垃圾回收的触发条件和执行时机可以归纳为以下几个方面：

1. 内存分配达到一定阈值
   Go 的垃圾回收器会根据程序的内存分配情况来决定何时执行回收。GC 会在程序的堆内存使用量达到一定阈值后自动触发。

Go 的 GC 机制是基于**内存分配比例（heap growth ratio）**的，这个比例通过环境变量 GOGC 来控制：

GOGC 环境变量：默认值为 100，表示当堆内存的使用量比上一次垃圾回收时增加了 100% 时，GC 就会触发。
比如，程序在一次 GC 后堆内存为 100MB，当堆内存达到 200MB 时，下一次 GC 会触发。
你可以通过设置 GOGC 的值来控制 GC 的频率：
如果设置 GOGC=200，表示堆内存需要增加 200% 才会触发下一次 GC，即会减少 GC 的频率。
如果设置 GOGC=50，表示内存只需要增加 50% 就会触发 GC，即会增加 GC 的频率。
设置为 GOGC=off，则会禁用 GC。

2. 手动触发 GC
   Go 提供了一个手动触发 GC 的函数 runtime.GC()，当你调用该函数时，垃圾回收器会立刻执行一次垃圾回收。这在需要主动释放内存的场景下很有用，尽管它通常不推荐在性能敏感的代码中频繁使用。
```go
import "runtime"

func main() {
    // 手动触发 GC
    runtime.GC()
}
```

需要注意的是，手动触发的 GC 可能会影响程序的性能，因为它会暂停部分 goroutine 执行并进行内存回收工作。

3. 定期触发
   除了内存分配达到阈值之外，Go 的垃圾回收器也会定期触发。GC 会通过运行时系统的调度器监控程序的执行状态，如果程序的堆内存增长较慢但运行时间较长，GC 也可能会被周期性地调用。

在某些情况下，GC 会进行后台垃圾回收，这是为了确保程序长时间运行时，内存不会持续增长而不被回收。

4. 调用 runtime.KeepAlive 防止过早回收
   Go 的垃圾回收器是基于引用追踪的。当某个对象没有任何引用时，它会被认为是不再使用的对象，GC 会在适当的时候回收该对象。但有时候，可能存在一些复杂的引用或资源管理情况，你可以使用 runtime.KeepAlive 明确告诉 GC 某个对象需要保留直到某个时刻。
```go
import "runtime"

func main() {
    obj := createObject()
    useObject(obj)
    runtime.KeepAlive(obj) // 确保 obj 在此之前不会被 GC 回收
}
```

5. GC 运行时的机制
   Go 的垃圾回收器是并发的，这意味着它不会完全阻塞程序的执行。GC 主要分为几个阶段：

标记阶段：GC 会从程序中的根对象（比如全局变量、栈上的局部变量等）开始，遍历对象图，标记出所有可达的对象。
清除阶段：GC 会清除未被标记的对象，这些对象被认为是不再使用的，可以安全地回收。
在标记阶段，Go 会通过三色标记算法（白、灰、黑三色）来管理对象的状态，并通过写屏障技术确保在并发执行过程中不会遗漏任何活跃对象。

6. GOGC 设置的影响
   通过调节 GOGC 的值，开发者可以控制 GC 的频率和内存的占用：

GOGC 增大（如 GOGC=200）：会减少 GC 的频率，内存占用会更大，但 GC 带来的性能开销会降低，适用于对内存不敏感的程序。
GOGC 减小（如 GOGC=50）：会增加 GC 的频率，内存占用减少，但 GC 的性能开销增大，适用于内存紧张但对 CPU 开销不太敏感的场景。
7. GC 对性能的影响
   尽管 Go 的 GC 是并发的，它仍然会带来一定的暂停时间（stop-the-world），特别是在标记阶段，程序的某些 goroutine 可能会被暂时挂起。不过，Go 的垃圾回收器经过多次优化，其对延迟的影响已经较小。通过适当的内存管理和调节 GOGC，可以减少 GC 对性能的影响。

总结

Go 的垃圾回收器主要在堆内存分配增长到一定阈值时触发，这个阈值可以通过 GOGC 控制。
开发者可以手动调用 runtime.GC() 来触发垃圾回收，但不推荐频繁使用。
Go 的垃圾回收器是并发的，使用标记-清除算法，能够在程序运行时高效管理内存，但会根据内存分配的情况来决定执行时机。
通过合理设置 GOGC 值，可以调节 GC 的频率，优化性能。
# Map同时读写会发生什么？读nil的时候呢？
```text
同时读写: 对同一个 map 进行并发读写操作时，如果没有同步措施，可能会导致数据竞争或程序崩溃。
读 nil: 读取 nil map 时不会导致错误，返回零值。
写 nil: 写入 nil map 会导致运行时错误
```

# 介绍一下golang map 底层数据结构实现?
Go 语言中的 map 数据结构是基于哈希表（Hash Table）实现的。它通过将键进行哈希运算，将哈希值映射到一个存储桶（bucket）中，从而实现快速的查找、插入和删除操作。

以下是 Go 语言中 map 底层数据结构的详细实现原理：

1. map 的核心结构
   Go 语言中的 map 数据结构在标准库中被定义为 hmap 结构体，核心数据结构主要包括以下几个部分：
```go
type hmap struct {
    count     int       // map 中存储的键值对数量
    B         uint8     // 当前 bucket 数量的对数（2^B = bucket 数量）
    hash0     uint32    // 随机的哈希种子，用于防止哈希碰撞攻击
    buckets   unsafe.Pointer // bucket 的数组，实际存储键值对的位置
    oldbuckets unsafe.Pointer // 用于扩容时保存旧的 bucket
    nevacuate uintptr  // 扩容时标记已搬迁的 bucket
    ...
}
```
2. 哈希桶（Bucket）的结构
   每个 bucket 是一个键值对的集合，在底层通过数组和链表结合实现。每个 bucket 中大约可以存储 8 个键值对。若某个 bucket 中的键值对超过 8 个，会在 overflow bucket 中继续存储，防止冲突。

bucket 的结构如下：
```go
type bmap struct {
    tophash [8]uint8  // 存储每个 key 的哈希值的高 8 位，用于快速比较
    // 后续存储实际的 key-value 对，紧跟在 tophash 后面
}
```
tophash：tophash 数组存储每个键哈希值的高 8 位，用于加速比较。当查找某个键时，先比较 tophash 是否匹配，然后再去 bucket 中查找对应的键值对。
overflow：当一个 bucket 装满时，Go 会分配一个 overflow bucket，类似于链表的概念，解决哈希冲突问题。

3. 哈希函数
   Go 使用 hash0 作为随机种子来计算哈希值，保证相同的键在不同的程序运行时不会总是映射到相同的 bucket，从而减少哈希碰撞攻击的风险。

哈希函数的计算步骤大致如下：

将 key 传入哈希函数。
使用 hash0 和哈希函数生成一个哈希值。
根据当前的 bucket 数量（2^B）对哈希值取模，找到对应的 bucket。

4. 查找过程
   map 的查找过程可以分为以下几步：

计算哈希值：对给定的键使用哈希函数，生成一个哈希值。
定位 bucket：根据哈希值和当前 bucket 数量，确定键应该存储在哪个 bucket。
比较 tophash：在 bucket 中，根据哈希值的高 8 位检查 tophash 数组，看是否有匹配的键。
匹配键值对：如果 tophash 匹配，再比较键是否相等。如果键相等，返回对应的值；如果不匹配，查找 overflow bucket。

5. 插入过程
   map 的插入过程如下：

计算哈希值：同样通过哈希函数计算键的哈希值。
定位 bucket：找到键值对应的 bucket。
查找空闲位置：在 bucket 中查找空闲位置，如果找到，直接存储键值对。
处理冲突：如果 bucket 已满，会使用 overflow bucket 存储多余的键值对。

6. 扩容机制
   Go 的 map 具有动态扩容功能，当装载因子（load factor，定义为 count / bucket数量）超过某个阈值时，map 会自动扩容。扩容机制的细节如下：

创建新 bucket：每次扩容，map 的 bucket 数量翻倍（即 B += 1）。
搬迁键值对：扩容时，map 会逐步将旧的键值对搬迁到新的 bucket 中。搬迁是增量进行的，这样可以避免在一次操作中全部重新哈希导致的性能抖动。
搬迁时，oldbuckets 用于保存旧的 bucket 数组，nevacuate 标记已经搬迁的 bucket。每次访问 map 时，如果发现有旧的 bucket 未搬迁，会顺便将该 bucket 搬迁到新表中。

7. 删除操作
   删除操作相对简单。首先定位到目标 bucket，然后将对应键值对置为零值，并更新计数器。如果有过多空闲的 bucket，map 会考虑缩容。

8. 并发访问
   Go 的 map 不是并发安全的，在并发场景下对 map 进行读写操作会引发数据竞态或程序崩溃。Go 语言提供了一个并发安全的 sync.Map，适合在并发环境中使用。

9. sync.Map 的设计
   sync.Map 是 Go 标准库提供的并发安全的 map 实现，内部使用了分段锁和延迟删除机制，允许多个 goroutine 并发访问。

总结

Go 语言中 map 的底层实现是基于哈希表的，它采用了哈希桶（bucket）来管理键值对，支持高效的插入、查找和删除操作。Go 通过哈希函数、哈希种子和增量扩容机制来优化性能，并减少哈希碰撞带来的影响。然而，map 在并发场景下并不安全，需要额外的同步机制来保证数据一致性。


# 如果我去map中删除了某个key，它的内存会释放吗？假如说这个key对应的value是个指针类型/引用类型的，它会释放内存吗
```text
删除值类型的键值对：当删除非引用类型的值时（如 int、float），GC 会在下一次运行时自动回收内存。

删除引用类型的键值对：当删除引用类型（如指针、切片、map 等）的值时，只要没有其他地方引用该值，GC 也会在适当时机回收内存。

GC 回收机制：Go 的垃圾回收器自动管理内存回收，因此你不需要手动释放内存，但要注意删除 map 键后，如果值仍被其他变量引用，内存不会被立即回收。

简而言之，delete 操作本身不会立即释放内存，内存释放由垃圾回收器在检测到该对象没有被引用时自动完成。

```


# golang 如果 map 数据扩容，这时正好有一条查询数据过来，他的执行流程是什么样子

在 Go 中，map 是一种无序的键值对集合。当 map 达到一定的负载因子（通常与其容量成比例）时，它会触发扩容（rehashing）。在扩容过程中，Go 会重新分配 map 的底层存储，并将现有的数据迁移到新的更大的数据结构中。

当 map 在扩容的过程中，恰好有一条查询数据请求过来，查询操作会与扩容操作并行执行。在 Go 中，map 并不是线程安全的，如果并发修改和查询没有加锁或使用同步机制（如 sync.Mutex），会导致数据不一致或程序崩溃。为了保证正确性，通常在并发访问 map 时需要额外的同步措施。

map 扩容和查询的执行流程
扩容和查询的具体执行流程如下：

#### 判断是否需要扩容：

当 map 的存储容量即将达到上限时，Go 的 map 结构会触发扩容。Go 的 map 扩容机制会将旧的存储分配到一个新的更大的底层存储结构中，并进行 rehashing，将键值对迁移到新的存储中。
扩容过程：

Rehashing：扩容过程中，map 的键值对会被重新计算哈希值并迁移到新的桶（bucket）中。Go 中 map 的底层实现是一个数组，每个数组位置称为一个 "bucket"，扩容时会重新分配更多的 bucket。
扩容操作并不是一次性将所有数据迁移到新存储的，它是渐进式的（incremental rehashing），这样可以减少每次扩容对性能的影响。每次读写操作时，都会逐步将一些旧 bucket 中的数据移动到新的 bucket 中。
查询操作流程：

##### 当 map 正在进行扩容时，如果有查询操作，查询流程会如下：
查询首先会根据键的哈希值找到对应的 bucket。
系统会检查当前 map 是否在进行扩容。如果正在扩容，则系统可能需要检查新旧两个 bucket。因为数据可能还没有完全从旧的 bucket 迁移到新的 bucket。
如果查询的键值对已经迁移到了新的 bucket，查询会直接从新的 bucket 读取数据。
如果查询的键值对还在旧的 bucket，查询会访问旧的 bucket 获取数据。

##### 并发情况下的问题：

Go 的 map 本身并不是线程安全的，如果在扩容时同时进行读写操作，可能导致数据的不一致，甚至引发程序崩溃（如 fatal error: concurrent map read and map write）。
如果需要保证并发读写安全，应该使用同步机制，比如 sync.Mutex 或 sync.RWMutex 来保护 map 的读写操作，或者使用 sync.Map，它是 Go 提供的线程安全的 map。
#### 总结
在 map 进行扩容时，查询操作会根据键的哈希值访问相应的 bucket。
扩容是渐进式的，查询时可能需要检查新旧 bucket。

Go map 在并发读写时不是线程安全的，需要加锁或使用线程安全的数据结构来保护并发访问。
在并发访问 map 时，确保同步操作至关重要，以避免扩容过程中可能出现的数据竞争和崩溃问题。

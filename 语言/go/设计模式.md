# 设计模式
设计模式是一套被反复验证的、用于解决特定场景下编程问题的最佳实践方法。它们能够提高代码的可重用性、可扩展性和可维护性。设计模式通常分为三大类：

1. 创建型模式（Creational Patterns）
   这些模式主要关注对象的创建方式，目的是将对象的创建过程与使用过程分离，从而提高系统的灵活性和复用性。

常见创建型模式：
工厂方法模式（Factory Method）：定义一个创建对象的接口，但让子类决定实例化哪个类。工厂方法使一个类的实例化延迟到其子类。

使用场景：当有多个子类，并且需要在运行时决定创建哪个子类的对象时。

抽象工厂模式（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。

使用场景：系统中有多个产品族，但一次只能消费一个产品族的情况。

单例模式（Singleton）：确保一个类只有一个实例，并提供一个全局访问点。

使用场景：在需要确保某个类有且仅有一个实例的场景，如数据库连接池或配置管理类。

原型模式（Prototype）：通过克隆原型来创建新对象，而不是通过构造函数创建对象。

使用场景：当对象的创建成本很高，并且需要复制对象的场景。

建造者模式（Builder）：将一个复杂对象的构建过程与它的表示分离，使得同样的构建过程可以创建不同的表示。

使用场景：需要一步步构建复杂对象的场景，如构建复杂的用户界面或生成复杂的文档。

2. 结构型模式（Structural Patterns）
   结构型模式涉及如何将对象和类组合在一起形成更大的结构，提供新的功能，同时保持系统的灵活性和扩展性。

常见结构型模式：
适配器模式（Adapter）：将一个类的接口转换成客户端期望的另一个接口，使原本由于接口不兼容而不能一起工作的类可以协同工作。

使用场景：系统需要使用现有的类，但这些类的接口与系统不兼容。

桥接模式（Bridge）：将抽象部分与实现部分分离，使它们都可以独立地变化。

使用场景：当需要在抽象和实现之间增加更多的灵活性，允许两者独立扩展时。

装饰者模式（Decorator）：动态地给一个对象添加一些额外的职责或行为。

使用场景：当需要为对象添加功能或行为，但不想改变对象的结构时。

外观模式（Facade）：为子系统中的一组接口提供一个统一的接口，从而简化子系统的使用。

使用场景：系统变得复杂，需要简化接口时。

代理模式（Proxy）：为其他对象提供一种代理以控制对这个对象的访问。

使用场景：为一个对象提供代理来控制对它的访问，如远程代理、虚拟代理、保护代理等。

组合模式（Composite）：将对象组合成树形结构以表示部分-整体的层次结构，使得客户端可以统一地对待单个对象和组合对象。

使用场景：需要处理一组相似的对象，将单个对象和组合对象统一处理的场景。

享元模式（Flyweight）：通过共享对象来减少内存消耗，适用于大量细粒度对象。

使用场景：需要大量重复对象并且想节省内存开销时。

3. 行为型模式（Behavioral Patterns）
   这些模式关注对象之间的通信和职责分配，目的在于使各个对象之间的通信更加灵活高效。

常见行为型模式：
责任链模式（Chain of Responsibility）：将请求沿着处理者链进行传递，直到有一个处理者处理该请求。

使用场景：需要为某个请求设置多个处理对象，但具体由哪个处理对象处理在运行时决定的场景。

命令模式（Command）：将请求封装成对象，以便使用不同的请求、队列或日志来参数化其他对象。

使用场景：需要对行为进行记录、撤销或者重做时。

迭代器模式（Iterator）：提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部表示。

使用场景：需要对容器中的元素进行遍历，而不想暴露其内部结构时。

中介者模式（Mediator）：用一个中介对象来封装一系列对象的交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散。

使用场景：系统中对象间存在复杂的相互依赖关系时。

备忘录模式（Memento）：在不破坏封装的前提下，捕获对象的内部状态，并在以后恢复它。

使用场景：需要保存和恢复对象的某个状态，以便在以后恢复状态时使用。

观察者模式（Observer）：定义对象之间的一对多依赖关系，当一个对象改变状态时，所有依赖于它的对象都会得到通知并自动更新。

使用场景：需要通知多个对象某个状态发生变化时。

状态模式（State）：允许对象在其内部状态改变时改变其行为。

使用场景：对象的行为依赖于其状态，且状态经常发生改变时。

策略模式（Strategy）：定义一系列算法，将每个算法封装起来，并使它们可以互换。

使用场景：需要动态选择算法的场景。

模板方法模式（Template Method）：在一个方法中定义一个算法的框架，而将某些步骤延迟到子类中实现。

使用场景：在一个算法的不同实现之间共享代码时。

访问者模式（Visitor）：定义表示元素的操作，将这些操作封装到访问者对象中，使得可以在不改变元素类的情况下定义新的操作。

使用场景：需要对一组对象执行不同操作时，不改变对象结构的前提下扩展功能。

总结
设计模式能够帮助我们编写更加灵活、可扩展和易维护的代码。理解并应用这些模式可以大大提高系统的设计质量。
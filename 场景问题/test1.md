# 设计题：微信PC端登录，用户拿手机端的微信扫二维码，一点授权登录，然后电脑端就自动登录成功了，如果让你来做这么个需求，你会怎么设计呢，主要讲讲接口设计，数据存储，交互过程等等（感觉当时卡了有近2分钟才答出PC端实现的关键点）
实现微信 PC 端登录功能，用户通过手机扫描二维码来完成授权，主要涉及到接口设计、数据存储、交互过程等方面。下面是一个设计方案：

## 交互过程
   1.1 用户流程：

用户在 PC 端打开微信登录页面，页面展示一个二维码。
用户用手机微信扫描 PC 端展示的二维码。
手机端微信弹出授权页面，用户点击授权。
授权成功后，PC 端自动登录，显示用户信息。
## 技术流程：

生成二维码：PC 端生成一个二维码，二维码中包含一个唯一的登录请求标识（UUID）。
扫描二维码：手机端扫描二维码并将登录请求标识发送到服务器。
用户授权：手机端显示授权页面，用户进行授权。
授权确认：服务器接收到授权确认后，更新登录状态。
PC 端轮询：PC 端定期向服务器询问是否已授权，若已授权则完成登录。
2. 接口设计
   2.1 生成二维码

接口：POST /api/generate_qr_code
请求参数：
client_id: PC 端客户端标识（唯一）
响应：
qr_code_url: 生成的二维码图片 URL
login_id: 唯一的登录请求标识（UUID）

2.2 扫描二维码
接口：POST /api/scan_qr_code
请求参数：
login_id: 二维码中的唯一标识
user_id: 手机端用户标识
响应：
status: 扫描成功状态

2.3 用户授权
接口：POST /api/authorize_login
请求参数：
login_id: 二维码中的唯一标识
user_id: 手机端用户标识
authorization: 授权状态（成功或失败）
响应：
status: 授权结果（成功或失败）

2.4 PC 端登录状态轮询
接口：GET /api/check_login_status
请求参数：
login_id: 唯一的登录请求标识
响应：
status: 登录状态（未授权、已授权）
user_info: 授权成功后返回的用户信息（如用户名、头像等）
## 数据存储
   3.1 数据库设计

表：login_requests
id (UUID, 主键): 登录请求标识
client_id (VARCHAR): PC 端客户端标识
user_id (VARCHAR): 用户标识
status (ENUM): 登录状态（pending、authorized、failed）
created_at (DATETIME): 请求创建时间
updated_at (DATETIME): 状态更新时间
3.2 存储设计

二维码数据：存储二维码生成的请求标识 login_id 和与之关联的 PC 端客户端标识 client_id。
授权数据：存储用户授权的状态 authorized 或 failed。
状态更新：更新登录请求的状态，以便 PC 端可以通过轮询接口获取当前登录状态。
4. 实现细节
   4.1 PC 端
生成二维码：在 PC 端登录页面请求 /api/generate_qr_code，并显示二维码图片。
轮询检查状态：通过定时任务（如使用 setInterval）向 /api/check_login_status 查询当前登录状态。
自动登录：当状态返回 authorized 时，完成自动登录，并显示用户信息。

4.2 手机端
扫描二维码：使用微信内置的扫描功能，识别二维码并向 /api/scan_qr_code 发送登录请求。
显示授权页面：展示授权页面并接收用户的授权请求。
授权请求：用户点击授权后，发送授权请求到 /api/authorize_login。

4.3 服务器
处理二维码生成请求：生成唯一的 login_id 并返回二维码 URL。
处理扫描二维码请求：记录扫描请求，并准备进入授权流程。
处理授权请求：更新登录状态并通知 PC 端用户已经授权。 
## 安全性和优化

   5.1 安全性
二维码加密：二维码中的登录请求标识应加密，防止被篡改。
验证请求：所有接口应验证请求来源，防止恶意请求。
数据加密：存储和传输的数据应加密，保护用户隐私。

5.2 优化
减少轮询频率：可以使用 WebSocket 实现实时通知，减少轮询请求的开销。

提高可靠性：使用分布式缓存（如 Redis）来存储登录状态，避免数据库负载过高。

通过上述设计，可以实现一个安全且高效的微信 PC 端登录功能，使用户通过手机扫描二维码完成登录。


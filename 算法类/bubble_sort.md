# go 实现冒泡排序
冒泡排序（Bubble Sort）是一种简单的排序算法，算法的基本思想是通过多次遍历数组，相邻元素两两比较并交换，使得较大的元素逐渐向数组的末端移动，最终将整个数组排序。

冒泡排序的步骤：
从数组的第一个元素开始，依次比较相邻的两个元素。
如果前面的元素比后面的元素大，就交换它们的位置。
经过一轮比较，数组中最大的元素会移动到数组的末尾。
重复上述过程，直到整个数组有序。
Go 实现冒泡排序
```go
package main

import (
    "fmt"
)

// bubbleSort 函数实现冒泡排序算法
func bubbleSort(arr []int) {
    n := len(arr)
    // 外层循环表示排序的轮数
    for i := 0; i < n-1; i++ {
        // 内层循环每次遍历数组的前 n-i-1 个元素
        // 因为每轮会把最大的元素“冒泡”到最后，所以无需再比较它们
        for j := 0; j < n-i-1; j++ {
            if arr[j] > arr[j+1] {
                // 交换相邻元素
                arr[j], arr[j+1] = arr[j+1], arr[j]
            }
        }
    }
}

func main() {
    arr := []int{64, 34, 25, 12, 22, 11, 90}
    fmt.Println("Unsorted array:", arr)

    bubbleSort(arr)

    fmt.Println("Sorted array:", arr)
}
```
```text
代码解释
bubbleSort 函数：实现了冒泡排序的核心逻辑。

外层循环 i 控制排序的轮数，总共需要进行 n-1 轮排序（n 为数组长度）。
内层循环 j 控制每一轮中的比较和交换操作，每次比较相邻两个元素，如果前者大于后者，则交换它们的位置。随着 i 的增加，最后的 i 个元素已经是有序的，因此内层循环只需要遍历 n-i-1 个元素。
main 函数：用于测试冒泡排序的实现。首先定义了一个未排序的数组，然后调用 bubbleSort 对数组进行排序，最后输出排序结果。

冒泡排序的时间复杂度
最优时间复杂度：O(n)（当数组已经有序时，通过优化可以提前退出）。
最差时间复杂度：O(n²)（当数组是逆序时，需要进行 n² 次比较和交换）。
平均时间复杂度：O(n²)。
空间复杂度
空间复杂度：O(1)（冒泡排序是原地排序算法，不需要额外的内存开销）。
总结
冒泡排序是一种简单但不高效的排序算法，适用于数据量较小或基本有序的场景。
通过加入标志位，可以在某些情况下优化冒泡排序，减少不必要的比较。
冒泡排序的最差时间复杂度为 O(n²)，因此对于大数据集，它并不是一个高效的选择。
```